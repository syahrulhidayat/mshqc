/**
 * @file src/scf/cholesky_uhf.cc
 * @brief FIXED: Complete SCFResult population for Post-SCF methods
 */
#include "mshqc/cholesky_uhf.h"
#include <iostream>
#include <iomanip>
#include <cmath>

namespace mshqc {

CholeskyUHF::CholeskyUHF(const Molecule& mol, const BasisSet& basis,
                         std::shared_ptr<IntegralEngine> integrals,
                         int n_alpha, int n_beta, const CholeskyUHFConfig& config)
    : mol_(mol), basis_(basis), integrals_(integrals), config_(config),
      n_alpha_(n_alpha), n_beta_(n_beta),
      diis_a_(config.diis_max_vectors), diis_b_(config.diis_max_vectors) {
    nbasis_ = basis.n_basis_functions();
    energy_ = 0.0;
}

void CholeskyUHF::init_integrals_and_cholesky() {
    S_ = integrals_->compute_overlap();
    Eigen::MatrixXd T = integrals_->compute_kinetic();
    Eigen::MatrixXd V = integrals_->compute_nuclear();
    H_ = T + V;
    
    Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(S_);
    X_ = es.operatorInverseSqrt();
    
    if (config_.print_level > 0) std::cout << "  > Decomposing ERIs..." << std::flush;
    auto eri_full = integrals_->compute_eri();
    cholesky_ = std::make_unique<integrals::CholeskyERI>(config_.cholesky_threshold);
    auto res = cholesky_->decompose(eri_full);
    n_cholesky_vectors_ = res.n_vectors;
    if (config_.print_level > 0) std::cout << " Done (" << n_cholesky_vectors_ << " vectors)\n";
}

void CholeskyUHF::initial_guess() {
    Eigen::MatrixXd H_bias = H_; 
    for(size_t i=0; i<nbasis_; i++) H_bias(i,i) -= 0.5;
    solve_fock(H_bias, C_a_, eps_a_);
    solve_fock(H_bias, C_b_, eps_b_);
    P_a_ = build_density(C_a_, n_alpha_);
    P_b_ = build_density(C_b_, n_beta_);
}

void CholeskyUHF::build_fock_cholesky() {
    F_a_ = H_;
    F_b_ = H_;
    const auto& L_vectors = cholesky_->get_L_vectors();
    Eigen::MatrixXd P_tot = P_a_ + P_b_;
    
    #pragma omp parallel 
    {
        Eigen::MatrixXd F_a_loc = Eigen::MatrixXd::Zero(nbasis_, nbasis_);
        Eigen::MatrixXd F_b_loc = Eigen::MatrixXd::Zero(nbasis_, nbasis_);
        
        #pragma omp for schedule(dynamic)
        for (int K = 0; K < n_cholesky_vectors_; K++) {
            Eigen::Map<const Eigen::MatrixXd> L_K_mat(L_vectors[K].data(), nbasis_, nbasis_);
            double J_val = (P_tot.cwiseProduct(L_K_mat)).sum();
            F_a_loc += J_val * L_K_mat;
            F_b_loc += J_val * L_K_mat;
            F_a_loc -= L_K_mat * P_a_ * L_K_mat;
            F_b_loc -= L_K_mat * P_b_ * L_K_mat;
        }
        #pragma omp critical
        {
            F_a_ += F_a_loc;
            F_b_ += F_b_loc;
        }
    }
}

void CholeskyUHF::solve_fock(const Eigen::MatrixXd& F, Eigen::MatrixXd& C, Eigen::VectorXd& eps) {
    Eigen::MatrixXd Fp = X_.transpose() * F * X_;
    Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(Fp);
    eps = es.eigenvalues();
    C = X_ * es.eigenvectors();
}

Eigen::MatrixXd CholeskyUHF::build_density(const Eigen::MatrixXd& C, int n_occ) {
    return C.leftCols(n_occ) * C.leftCols(n_occ).transpose();
}

double CholeskyUHF::compute_energy() {
    return 0.5 * ((P_a_ * (H_ + F_a_)).trace() + (P_b_ * (H_ + F_b_)).trace());
}

SCFResult CholeskyUHF::compute() {
    init_integrals_and_cholesky();
    initial_guess();
    
    int iter = 0;
    for (iter = 1; iter <= config_.max_iterations; iter++) {
        energy_old_ = energy_;
        build_fock_cholesky();
        
        Eigen::MatrixXd err_a = F_a_*P_a_*S_ - S_*P_a_*F_a_;
        Eigen::MatrixXd err_b = F_b_*P_b_*S_ - S_*P_b_*F_b_;
        diis_a_.add_iteration(F_a_, err_a);
        diis_b_.add_iteration(F_b_, err_b);
        if(iter > 1) { F_a_ = diis_a_.extrapolate(); F_b_ = diis_b_.extrapolate(); }

        solve_fock(F_a_, C_a_, eps_a_);
        solve_fock(F_b_, C_b_, eps_b_);
        P_a_ = build_density(C_a_, n_alpha_);
        P_b_ = build_density(C_b_, n_beta_);
        
        energy_ = compute_energy();
        if (std::abs(energy_ - energy_old_) < config_.energy_threshold) break;
    }
    
    // POPULATE FULL RESULT (CRITICAL FOR MP2)
    SCFResult res;
    res.energy_total = energy_ + mol_.nuclear_repulsion_energy();
    res.energy_electronic = energy_;
    res.energy_nuclear = mol_.nuclear_repulsion_energy();
    res.iterations = iter;
    res.converged = (iter <= config_.max_iterations);
    
    // Orbitals & Energies (Ini yang bikin crash kalau hilang)
    res.C_alpha = C_a_;
    res.C_beta = C_b_;
    res.orbital_energies_alpha = eps_a_;
    res.orbital_energies_beta = eps_b_;
    res.P_alpha = P_a_;
    res.P_beta = P_b_;
    res.n_occ_alpha = n_alpha_;
    res.n_occ_beta = n_beta_;
    
    return res;
}

} // namespace
